## CVE-2024-37902

https://github.com/advisories/GHSA-w877-jfw7-46rj

Уязвимость заключается в том, что в архиве ZIP или TAR злоумышленник может использовать последовательности для выхода за
пределы целевой директории (например, ../) и, таким образом, перезаписывать произвольные файлы в системе

## POC

[AIDjlAttack.java](../../src/main/java/org/example/AIDjlAttack.java)

В результате распаковки архивов (zip/tar) перезапишется произвольный файл в системе

## Sink

java.nio.file.Files#copy

## CodeQL

ZipSlip.ql нашел 6 уязвимостей:

- 3 для метода TarUtils.untar
- 3 для метода ZipUtils.unzip

### TarUtils.untar

1. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (5 steps)
   1 getName(...) : String TarUtils.java:51:36
   2 entryName : String TarUtils.java:55:41
   3 resolve(...) : Path TarUtils.java:55:29
   4 toAbsolutePath(...) : Path TarUtils.java:55:29
   5 file TarUtils.java:57:45

Это false-positive, так как тут (`Files.createDirectories(file);`) всего лишь создаётся директория, если она до этого не
была создана. Более того, сообщение об ошибке ("may contain '..'") неверное, так как entryName не может содержать ".."
после проверки:

```
if (entryName.contains("..")) {
    throw new IOException("Malicious zip entry: "+entryName);
}
```

2. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (7 steps)
   1 getName(...) : String TarUtils.java:51:36
   2 entryName : String TarUtils.java:55:41
   3 resolve(...) : Path TarUtils.java:55:29
   4 toAbsolutePath(...) : Path TarUtils.java:55:29
   5 file : Path TarUtils.java:59:39
   6 getParent(...) : Path TarUtils.java:59:39
   7 parentFile TarUtils.java:63:45

Это false-positive аналогично предыдущему

3. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (5 steps)
   1 getName(...) : String TarUtils.java:51:36
   2 entryName : String TarUtils.java:55:41
   3 resolve(...) : Path TarUtils.java:55:29
   4 toAbsolutePath(...) : Path TarUtils.java:55:29
   5 file TarUtils.java:64:37

Если смотреть только на сообщение, то это false-positive опять по причине того, что entryName не может содержать ".."
после проверки.
Но по факту, это реальная уязвимость, так как entryName всё ещё может быть __абсолютным__ путем, например, "
/etc/hosts" — таким образом можно перезаписать любой файл в системе
Если создание произвольной директории тоже считаем уязвимостью, то и предыдущие 2 результата тоже не FP

### ZipUtils.unzip

4. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (5 steps)
   1 getName(...) : String ZipUtils.java:55:27
   2 name : String ZipUtils.java:60:38
   3 resolve(...) : Path ZipUtils.java:60:25
   4 toAbsolutePath(...) : Path ZipUtils.java:60:25
   5 file ZipUtils.java:62:41

5. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (7 steps)
   1 getName(...) : String ZipUtils.java:55:27
   2 name : String ZipUtils.java:60:38
   3 resolve(...) : Path ZipUtils.java:60:25
   4 toAbsolutePath(...) : Path ZipUtils.java:60:25
   5 file : Path ZipUtils.java:64:35
   6 getParent(...) : Path ZipUtils.java:64:35
   7 parentFile ZipUtils.java:68:41

6. Unsanitized archive entry, which may contain '..', is used in a file system operation.
   Path (5 steps)
   1 getName(...) : String ZipUtils.java:55:27
   2 name : String ZipUtils.java:60:38
   3 resolve(...) : Path ZipUtils.java:60:25
   4 toAbsolutePath(...) : Path ZipUtils.java:60:25
   5 file ZipUtils.java:69:33

Отдельно каждый комментировать не буду, так как тут результаты аналогичны TarUtils: 2 уязвимости про создание директории
и 1 про создание/перезапись файла. Если смотреть на имя найденной уязвимости, то это FP, так как опять же ".." не может
быть в `entry` после проверки

```
if (name.contains("..")) {
    throw new IOException("Malicious zip entry: "+name);
}
```

Но при этом последний результат является реальной уязвимостью, так как можно подставить __абсолютный__ путь в
`entryName`

## Fix

https://github.com/deepjavalibrary/djl/pull/3075/files

```java
static String removeLeadingFileSeparator(String name) {
    int index = 0;
    for (; index < name.length(); index++) {
        if (name.charAt(index) != File.separatorChar) {
            break;
        }
    }
    return name.substring(index);
}
```

И потом при распаковке tar и zip архивов:

```java
String name = removeLeadingFileSeparator(entry.getName());
```

Фикс тривиальный: если нам передали абсолютный путь, то он обязательно начинается с "/" (или нескольких "/"). Функция
`removeLeadingFileSeparator` удаляет все "/" из начала, таким образом получается путь становится относительным (начиная
с точки распаковки). Проверка на ".." уже была в коде раньше, поэтому теперь все странные пути стали корректно
обрабатываться
